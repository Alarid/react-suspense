# Render as you fetch

## Background

This one's a bit of a mind bender, but here's the ultimate goal we're looking
for: https://twitter.com/kentcdodds/status/1191922859762843649

We wont get the whole way there in this exercise, but we'll get a bunch of the
way there. Then in exercise 04 we can finish it up. So fast âš¡

The idea here is that: get the data as soon as you have the information you need
for the data. This sounds obvious, but if you think about it, how often do you
have a component that requests data once it's been mounted. There's a few
milliseconds between the time you click "go" and the time that component is
mounted... Unless that component's code is lazy-loaded. In which case, there's a
lot more time involved and your users are hanging around waiting while they
could be making requests for the data they need.

That's the entire idea behind "Render as you fetch."

The information often involves a user's

## Exercise

In this one, we now have a form that allows us to choose a pokemon by any name.
As soon as the user hits "submit", we pass the `pokemonName` to our
`PokemonInfo` component which makes the request to get the pokemon data (using
`useEffect`).

For the exercise, you need to refactor this from `useEffect` to Suspense. You'll
need to add the `ErrorBoundary` and `Suspense` components to the `PokemonInfo`
component, and you'll pass the pokemon resource to `PokemonInfoView` which will
call `.read()` on the resource. The initial `.read()` call will trigger the
component to suspend and display the fallback state. When the promise resolves,
React will re-render our components and we'll be able to display the pokemon.

> The real important parts of the render-as-you-fetch approach comes in the
> extra credit, but changing things to this will help a lot to get us going.

## Extra Credit

So far, we've benefitted from an API standpoint. I think the Suspense solution
is simpler than the `useEffect` version. However, we've not gotten the "Render
as you fetch" benefit when it comes to asynchronously loading the code we need.

These extra credit allow you to compare the two approaches.

ðŸ¦‰ For both of these, we're calling `window.fetch.restoreOriginalFetch()` at the
top of our file so our fetch requests actually hit the network so we can see
them in the network tab.

### ðŸ’¯ Lift resource state

Right now, our resource state lives in the same component that our `useEffect`
was in.

### ðŸ’¯ Compare "fetch on render" with "render as you fetch"

For this one, you don't actually have code changes to make, instead you'll open
the finished version of the extra credit and take a look at the network tab.

Open both
[`02-extra.1`](http://localhost:3000/isolated/exercises-final/02-extra.1) and
[`02-extra.2`](http://localhost:3000/isolated/exercises-final/02-extra.2).

In the first, we're doing all the resource fetching from within the component
itself.

For this one, you'll be working in `src/exercises/02-effect.js`. If you've
already edited this file, reset it by running:

```
git checkout src/exercises/02-effect.js
```

Now, you can completely delete the `PokemonInfo` component and instead do this:

```javascript
const PokemonInfo = React.lazy(() =>
  import('../lazy/pokemon-info-fetch-on-render-02'),
)
```

That should be all you need to do to get going. Pull up the Network tab and
watch the waterfall when you select a pokemon.

ðŸ“œ You may want to
[use Chrome's Network Throttle Feature](https://developers.google.com/web/tools/chrome-devtools/network#throttle)
to bring it down to "Slow 3G"

### ðŸ’¯ lazy load pokemon-info-render-as-you-fetch

For this one, you'll be working in `src/exercises/02.js`. You'll need to have
finished the exercise first before this will work.

Now, you can completely delete the `PokemonInfo` component and instead do this:

```javascript
const PokemonInfo = React.lazy(() =>
  import('../lazy/pokemon-info-render-as-you-fetch-02'),
)
```

But that's not all. One of the nice things about the `useEffect` version is that
the code for fetching the data is colocated with the code that needs the data.
This is why we often "Fetch on render" naturally. But we can have our colocation
goodness and our "Render as you fetch" too by putting that code in a separate
file. I've already done this for you, so at the top of the file, add this
import:

```javascript
import createPokemonInfoResource from '../lazy/pokemon-info-render-as-you-fetch-02.data'
```

Then where you're calling `setPokemonResource` do this:
`setPokemonResource(createPokemonResource(newPokemonName))` and checkout the
network tab. Compare that to the "Fetch on render approach"

ðŸ“œ You may want to
[use Chrome's Network Throttle Feature](https://developers.google.com/web/tools/chrome-devtools/network#throttle)
to bring it down to "Slow 3G"
